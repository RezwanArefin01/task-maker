syntax = "proto3";

package proto;

import "task.proto";
import "event.proto";

enum CacheMode {
  NOTHING = 0;
  GENERATION = 1;
  ALL = 2;
}

message EvaluateTaskRequest {
  Task task = 1;
  repeated SourceFile solutions = 2;
  string store_dir = 3;
  string temp_dir = 4;
  map<int64,string> write_inputs_to = 5;
  map<int64,string> write_outputs_to = 6;
  string write_checker_to = 7;
  CacheMode cache_mode = 8;
  int32 num_cores = 9;
  bool dry_run = 10;
  string evaluate_on = 11;
  bool exclusive = 12;
  bool keep_sandbox = 13;
  float extra_time = 14;
}

message TerrySolution {
  SourceFile solution = 1;
  int64 seed = 2;
}

message EvaluateTerryTaskRequest {
  TerryTask task = 1;
  repeated TerrySolution solutions = 2;
  string store_dir = 3;
  string temp_dir = 4;
  CacheMode cache_mode = 5;
  int32 num_cores = 6;
  bool dry_run = 7;
  string evaluate_on = 8;
  bool exclusive = 9;
  bool keep_sandbox = 10;
}

message CleanTaskRequest {
  string store_dir = 1;
  string temp_dir = 2;
}

message CleanTaskResponse {
}

message StopRequest {
  int64 evaluation_id = 1;
}

message StopResponse {
}

message ShutdownRequest {
  // If true, exit immediately, otherwise wait for evaluations to finish.
  bool force = 1;
}

message ShutdownResponse {
}

service TaskMakerManager {
  rpc EvaluateTask(EvaluateTaskRequest) returns (stream Event);
  rpc EvaluateTerryTask(EvaluateTerryTaskRequest) returns (stream Event);
  rpc CleanTask(CleanTaskRequest) returns (CleanTaskResponse);
  rpc Stop(StopRequest) returns (StopResponse);
  rpc Shutdown(ShutdownRequest) returns (ShutdownResponse);
}
